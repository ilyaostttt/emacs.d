(require 'cl)

(defun make-int-list ()
  (mapcar 'string-to-int
          (split-string (buffer-string))))

(defun store-credit ()
  (interactive)
  (let* ((list-of-numbers (make-int-list))
         (number-of-cases (car list-of-numbers))
         (working-list (cdr list-of-numbers)))
    (dotimes (case-number number-of-cases)
      (let* ((credit (car working-list))
             (number-of-items (cadr working-list))
             (items (make-vector number-of-items 0)))
        (setq working-list (cddr working-list))
        (dotimes (item-index number-of-items)
          (aset items item-index (car working-list))
          (setq working-list (cdr working-list)))
        (do ((i 0 (+ 1 i))
             (match-found nil))
            ((or (eql i (- number-of-items 1)) match-found))
          (do ((j (+ i 1) (+ j 1)))
              ((or (eql j number-of-items) match-found))
            (when (eql (+ (aref items i)
                          (aref items j))
                       credit)
              (insert (format "Case #%d: %d %d\n" (+ case-number 1) (+ i 1) (+ j 1)))
              (setq match-found t))))))))
